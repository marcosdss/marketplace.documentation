---
slug: release-20240412
authors: [gustavo]
tags: [spike]
---

# Spike - LIONS 339

## Carrinho | Substituição de produto

## 1. Introdução

Desejamos que seja feito um estudo de viabilidade de implementação de substituição de produto no carrinho de compras, como opções de produto semelhantes aos produtos que o cliente adicionou no carrinho inicialmente, para que ele selecione alguma substituição, se necessário, para que a operação de loja tenha sempre uma segunda opção em caso de produto faltante/ sem estoque.

As opções devem estar listadas na etapa do “/cart” por ser customizada e não nativa VTEX, além de ser onde o cliente confirma todos os produtos e quantidades, antes de pagar e fechar o pedido.

## 2. É Possível Realizar a Criação desse Componente?

Sim, é possível criar esse componente com base nas especificações fornecidas. No entanto, existem algumas considerações importantes:

- A busca por produtos similares será realizada apenas com base no `nome` do produto inicial. Por exemplo, se o cliente adicionou ao carrinho o produto "`Mandioca Descascada E Embalada A Vácuo`", a busca será feita usando apenas a palavra "`Mandioca`" para encontrar produtos similares.
- A funcionalidade atual não suporta a busca por produtos com base em categorias. A busca será restrita apenas ao nome do produto.
- As opções selecionadas pelo usuário ficarão salvas em um `localStorage`.
- Este estudo de viabilidade não inclui o desenvolvimento do layout do componente. O layout será tratado em uma etapa posterior, de acordo com o design fornecido no Figma.

Com base nessas considerações, a decisão de prosseguir com a criação do componente deve ser tomada pela PO do time, considerando os requisitos do projeto e as limitações identificadas.

## 3. Diretrizes para o Desenvolvimento

Para desenvolver este componente, devemos seguir as seguintes diretrizes:

- Utilizar a API `vtex.order-manager/OrderForm` para acessar as informações do carrinho de compras, garantindo uma integração suave com o sistema de gerenciamento de pedidos da plataforma VTEX.
- Utilizar a API de `catálogo` para buscar produtos similares ao item adicionado ao carrinho, garantindo uma experiência de substituição eficaz e relevante para o cliente.
- Implementar checkbox para facilitar a seleção dos produtos substitutos, oferecendo uma interface intuitiva e fácil de usar para os clientes.

## 4. Sugestão de Desenvolvimento Interno

Segue uma sugestão de implementação para o novo componente:

### 4.1. Importações de Bibliotecas e Definição de Interface:

Nesta seção, foram importadas as bibliotecas necessárias para o componente e definimos a interface `ProductInfo` para descrever a estrutura dos objetos de informações do produto. Além disso, definimos a interface `SelectedProduct` para representar os produtos selecionados, incluindo um rótulo para indicar a posição da opção selecionada.

```js
import React, { useEffect, useState } from "react";
import { useItemContext } from 'vtex.product-list/ItemContext';
import { useOrderForm } from 'vtex.order-manager/OrderForm';
import { promotionsRules } from "../AddCommentInProduct/promotionRules";
import { currentStoragedComment } from "../AddCommentInProduct/handleLocalStorage";
import constants from "../../constants";

import styles from './styles.css';

interface ProductInfo {
  id: string;
  name: string;
  image: string;
  price: number;
}

interface SelectedProduct {
  id: string;
  name: string;
  image: string;
  price: number;
  label: string;
}
```

### 4.2. Buscando as Informações do Pedido

Nesta seção, estamos utilizando hooks de contexto, como `useOrderForm` e `useItemContext`, para acessar informações do pedido atual e do item atual. Além disso, estamos recuperando os dados armazenados no `localStorage`, como as opções selecionadas anteriormente.

```js
  const { orderForm } = useOrderForm();
  const { item: { id, name, sellingPrice, productId, refId } } = useItemContext();

  const responseLocalStorage = localStorage.getItem(constants.KEY_LOCALSTORAGE_COMMENTS);
  const initialSelectedOptions = localStorage.getItem('selectedOptions');
```

### 4.3. Definição de Variáveis de Estado:

Nesta seção, estamos utilizando o hook `useState` para definir diferentes estados locais no componente. Esses estados incluem a opção selecionada, o estado de abertura da seleção de opções, um indicador de duplicação de produto, a lista de opções selecionadas e os produtos buscados.

```js
  const [option, setOption] = useState('');
  const [optionOpen, setOptionOpen] = useState(false);
  const [isProductDuplicated, setIsProductDuplicated] = useState(false);
  const [selectedOptions, setSelectedOptions] = useState<SelectedProduct[]>(initialSelectedOptions ? JSON.parse(initialSelectedOptions) : []);
  const [fetchedProduct, setFetchedProduct] = useState<any>(null);
```

### 4.4. definindo o useEffect

Nesta seção, estamos utilizando o hook `useEffect` para realizar ações sempre que certas variáveis mudarem. Quando o `orderForm` ou `responseLocalStorage` mudam, executamos funções para atualizar a opção selecionada e verificar regras de promoção para o item atual.

```js
  useEffect(() => {
    currentStoragedComment(responseLocalStorage, id, setOption);
    promotionsRules(orderForm, id, sellingPrice, productId, setIsProductDuplicated);
  }, [orderForm, id, responseLocalStorage, sellingPrice, productId]);
```

### 4.5. Busca de Produtos na API de Catálogo

Nesta parte, definimos uma função chamada `fetchData` que busca os dados do produto usando uma API quando o botão para selecionar as opções é clicado. Utilizamos o hook `useEffect` para disparar essa busca sempre que o estado `optionOpen` ou o nome do produto mudar.

```js
  useEffect(() => {
    const fetchData = async () => {
      const productName = name.split(' ')[0];
      const response = await fetch(`/api/catalog_system/pub/products/search?fq=productName:${productName}`, {
        method: "GET",
        headers: {
          Accept: "application/json",
          "REST-range": "resources=0-10",
          "Content-Type": "application/json; charset=utf-8",
        }
      });
      const data = await response.json();
      setFetchedProduct(data);
    };

    if (optionOpen) {
      fetchData();
    }
  }, [optionOpen, name]);
```

### 4.6. Atualizando Seleção com localStorage

Nesta seção, temos a função `handleOptionChange` que é chamada quando uma opção de produto é selecionada. Ela atualiza o estado `selectedOptions` com a opção selecionada, adicionando um rótulo indicando a posição da opção. Além disso, as informações da opção selecionada são salvas no `localStorage`, garantindo que a seleção seja persistida entre sessões.

```js
  const fetchedProductInfo: ProductInfo[] = Array.isArray(fetchedProduct)
    ? fetchedProduct.map((item: any) => ({
      id: item.productId,
      name: item.productName,
      image: item.items[0].images[0].imageUrl,
      price: item.items[0].sellers[0].commertialOffer.Price
    }))
    : [];

  const handleOptionChange = (option: ProductInfo) => {
    const selectedProduct: SelectedProduct = {
      ...option,
      label: `${selectedOptions.length + 1}ª opção`
    };

    const existingIndex = selectedOptions.findIndex(prod => prod.id === option.id);
    if (existingIndex === -1) {
      const updatedOptions = [...selectedOptions, selectedProduct];
      setSelectedOptions(updatedOptions);
      localStorage.setItem('selectedOptions', JSON.stringify(updatedOptions));
    } else {
      const updatedOptions = [...selectedOptions];
      updatedOptions.splice(existingIndex, 1);
      setSelectedOptions(updatedOptions);
      localStorage.setItem('selectedOptions', JSON.stringify(updatedOptions));
    }

    localStorage.setItem('selectedProduct', JSON.stringify(selectedProduct));
  };
```

### 4.7. Condicional para a renderização

Neste trecho, verificamos se o nome do produto inclui "kit", se o produto está duplicado ou se o `refId` inclui "kit". Se alguma dessas condições for verdadeira, o componente retorna `null`, o que significa que ele não será renderizado.

```js
  if (name?.toLowerCase().includes('kit') || isProductDuplicated || refId?.toLowerCase().includes('kit')) {
    return null;
  }
```

### 4.8. Renderizaçãodo componente

Neste trecho, estamos retornando o JSX que representa a estrutura e o conteúdo do componente `ProductReplacement`, incluindo botões, texto, opções de seleção de produto, etc.

```js
return (
    <div key={id} className={styles.addCommentInCartContainer}>
      <button
        className={styles.button}
        onClick={() => setOptionOpen(!optionOpen)}
      >
        {option ? `Se faltar, você prefere: ${fetchedProductInfo.find(item => item.id === option)?.name}` : 'Se faltar, você prefere:'}
      </button>
      {optionOpen && (
        <div className={styles.textCommentContainer}>
          {fetchedProduct && fetchedProduct.length > 0 && (
            <div className={styles.textCommentContainer}>
              {fetchedProductInfo.map((item: ProductInfo) => (
                <label key={item.id} className={styles.productOption}>
                  <input
                    type="checkbox"
                    name="productOption"
                    value={item.id}
                    checked={selectedOptions.some(option => option.id === item.id)}
                    onChange={() => handleOptionChange(item)}
                  />
                  <img src={item.image} className={styles.productImg} alt={item.name} />
                  <p className={styles.textComment}>{item.price}</p>
                  <p className={styles.name}>{item.name}</p>
                </label>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
```

### 4.9. Chamando o Componente na Store

Por se tratar de um componente que irá apenas no carrinho de compras, será necessário chamá-lo em apenas um arquivo: `store\blocks\pages\cart\desktop-cart.jsonc`. Para que a alteração funcione corretamente, chame o componente dentro de um dos blocos abaixo:

```jsonc
  "product-list-content-desktop#checkout-cart": {
    "children": ["flex-layout.row#main-container-checkout.desktop", "product-replacement"]
  },
  "flex-layout.col#checkout-price": {
    "children": ["flex-layout.row#checkout-price-total"]
  },
  "flex-layout.row#main-container-checkout.desktop": {
    "children": [
      "flex-layout.col#image-column.checkout",
      "flex-layout.col#checkout-cart-product-name",
      "flex-layout.col#unit-price-checkout",
      "flex-layout.col#checkout-quantity-selector",
      "flex-layout.col#checkout-price",
      "flex-layout.col#remove"
    ],
    "props": {
      "blockClass": "checkout-product-container",
      "colSizing": "auto",
      "horizontalAlign": "left",
      "preserveLayoutOnMobile": true,
      "border": "bottom",
      "borderColor": "gray-variation",
      "paddingTop": 1
    }
  }
```


## 5. Repositório Usado para Testes

Para essa spike foi utilizado o repositório [oba.cart-components](https://github.com/ObaHortifrutiDeveloper/oba.cart-components).
